{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-airflux-serialization","title":"Welcome to Airflux serialization","text":"<p>The Kotlin library for parsing, validation, and generating data in the JSON (JavaScript Object Notation) format. The library doesn't use code generation or reflection.</p> <p>Documentation in progress.</p>"},{"location":"env/","title":"The environment","text":""},{"location":"env/#the-readers-environment","title":"The reader's environment","text":""},{"location":"env/#the-writers-environment","title":"The writer's environment","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#gradle","title":"Gradle","text":"<p>Added the repository</p> <pre><code>repositories {\nmaven {\nurl = uri(\"https://jitpack.io\")\n}\n}\n</code></pre> <p>Added the serialization library</p> <pre><code>dependencies {\nimplementation(\"com.github.airflux.airflux:airflux-serialization-core:version\")\nimplementation(\"com.github.airflux.airflux:airflux-serialization-dsl:version\")\nimplementation(\"com.github.airflux.airflux:airflux-serialization-std:version\")\n}\n</code></pre> <p>Added the parser for JSON</p> <pre><code>dependencies {\nimplementation(\"com.github.airflux.airflux:airflux-jackson-parser:version\")\nimplementation(\"com.fasterxml.jackson.core:jackson-core:2.13.3\")\nimplementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:2.13.3\") {\nexclude(group = \"org.jetbrains.kotlin\")\n}\n}\n</code></pre>"},{"location":"installation/#maven","title":"Maven","text":"<p>Added the repository</p> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n&lt;id&gt;jitpack.io&lt;/id&gt;\n&lt;url&gt;https://jitpack.io&lt;/url&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> <p>Added the serialization library</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;airflux-serialization-core&lt;/artifactId&gt;\n&lt;version&gt;version&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;airflux-serialization-dsl&lt;/artifactId&gt;\n&lt;version&gt;version&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;airflux-serialization-std&lt;/artifactId&gt;\n&lt;version&gt;version&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Added the parser for JSON</p> <pre><code>&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;airflux-jackson-parser&lt;/artifactId&gt;\n&lt;version&gt;version&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n&lt;version&gt;2.13.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.github.airflux.airflux&lt;/groupId&gt;\n&lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt;\n&lt;version&gt;2.13.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#the-domain-types","title":"The domain types","text":"<pre><code>data class User(val id: Int, val name: String, val phones: Phones)\ndata class Phones(private val items: List&lt;Phone&gt;) : List&lt;Phone&gt; by items\ndata class Phone(val title: String, val number: String)\n</code></pre>"},{"location":"quickstart/#configuration-the-jackson","title":"Configuration the Jackson","text":"<p>Registering the module 'AirFluxJsonModule' with Jackson to use its parser</p> <pre><code>val mapper = ObjectMapper().apply {\nregisterModule(AirFluxJsonModule)\n}\n</code></pre>"},{"location":"quickstart/#reading","title":"Reading","text":""},{"location":"quickstart/#the-example-of-json","title":"The example of JSON","text":"<pre><code>val JSON = \"\"\"\n{\n  \"id\": 42,\n  \"name\": \"User\",\n  \"phones\": [\n    {\n      \"title\": \"mobile\",\n      \"number\": \"+0123456789\"\n    }\n  ]\n}\n\"\"\"\n</code></pre>"},{"location":"quickstart/#deserialization-json","title":"Deserialization JSON","text":"<pre><code>val parsedUser = JSON.deserialization(\nmapper = mapper,\nenv = readerEnv,\ncontext = readerCtx,\nreader = UserReader\n).orThrow { IllegalStateException() }\n</code></pre>"},{"location":"quickstart/#define-the-environment-for-reading","title":"Define the environment for reading","text":"<p>Define the environment to deserialization of some domain type using the reader</p> <pre><code>val readerEnv = ReaderEnv(\nerrorBuilders = ReaderErrorBuilders,\noptions = ReaderOptions(failFast = true)\n)\n</code></pre> <ul> <li>Define error builders for the reading environment</li> </ul> <pre><code>object ReaderErrorBuilders : InvalidTypeErrorBuilder,\nPathMissingErrorBuilder,\nValueCastErrorBuilder,\nIsNotBlankStringValidator.ErrorBuilder,\nPatternStringValidator.ErrorBuilder,\nIsNotEmptyStructValidator.ErrorBuilder,\nAdditionalPropertiesStructValidator.ErrorBuilder,\nAdditionalItemsErrorBuilder,\nIsNotEmptyArrayValidator.ErrorBuilder,\nMinimumNumberValidator.ErrorBuilder {\n//Reading error builders\noverride fun invalidTypeError(expected: Iterable&lt;String&gt;, actual: String): ReaderResult.Error =\nJsonErrors.InvalidType(expected = expected, actual = actual)\noverride fun pathMissingError(): ReaderResult.Error = JsonErrors.PathMissing\noverride fun valueCastError(value: String, target: KClass&lt;*&gt;): ReaderResult.Error =\nJsonErrors.ValueCast(value, target)\n//String validation error builders\noverride fun isNotBlankStringError(): ReaderResult.Error = JsonErrors.Validation.Strings.IsBlank\noverride fun patternStringError(value: String, pattern: Regex): ReaderResult.Error =\nJsonErrors.Validation.Strings.Pattern(value, pattern)\n//Object validation error builders\noverride fun isNotEmptyStructError(): ReaderResult.Error = JsonErrors.Validation.Struct.IsEmpty\noverride fun additionalPropertiesStructError(): ReaderResult.Error =\nJsonErrors.Validation.Struct.AdditionalProperties\n//Array validation error builders\noverride fun isNotEmptyArrayError(): ReaderResult.Error = JsonErrors.Validation.Arrays.IsEmpty\noverride fun additionalItemsError(): ReaderResult.Error = JsonErrors.Validation.Arrays.AdditionalItems\n//Number validation error builders\noverride fun minimumNumberError(expected: Number, actual: Number): ReaderResult.Error =\nJsonErrors.Validation.Numbers.Min(expected = expected, actual = actual)\n}\n</code></pre> <ul> <li>Define parsing and validation errors</li> </ul> <pre><code>sealed class JsonErrors : ReaderResult.Error {\nobject PathMissing : JsonErrors()\ndata class InvalidType(val expected: Iterable&lt;String&gt;, val actual: String) : JsonErrors()\ndata class ValueCast(val value: String, val type: KClass&lt;*&gt;) : JsonErrors()\nsealed class Validation : JsonErrors() {\nsealed class Struct : Validation() {\nobject IsEmpty : Struct()\nobject AdditionalProperties : Struct()\n}\nsealed class Arrays : Validation() {\nobject IsEmpty : Arrays()\nobject AdditionalItems : Arrays()\n}\nsealed class Strings : Validation() {\nobject IsBlank : Strings()\nclass Pattern(val value: String, val pattern: Regex) : Strings()\n}\nsealed class Numbers : Validation() {\nclass Min&lt;T&gt;(val expected: T, val actual: T) : Numbers()\n}\n}\n}\n</code></pre> <ul> <li>Define the options for the reading environment</li> </ul> <pre><code>class ReaderOptions(override val failFast: Boolean) : FailFastOption\n</code></pre>"},{"location":"quickstart/#define-the-context-for-reading","title":"Define the context for reading","text":"<pre><code>val readerCtx = ReaderCtx(\"123\")\n</code></pre> <ul> <li>Define the context for the reading environment</li> </ul> <pre><code>class ReaderCtx(val id: String)\n</code></pre>"},{"location":"quickstart/#define-readers-for-domain-types","title":"Define readers for domain types","text":"<ul> <li>Define the generic readers</li> </ul> <pre><code>// Primitive type readers\nval IntReader = intReader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx&gt;()\nval StringReader = stringReader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx&gt;()\n// The generic reader for the id property\nval PositiveNumberReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, Int&gt; =\nIntReader.validation(StdNumberValidator.minimum(0))\n// The generic reader for the username property\nval NonEmptyStringReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, String&gt; =\nStringReader.validation(isNotBlank)\n// The reader for the phone number property\nval PhoneNumberReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, String&gt; =\nNonEmptyStringReader.validation(StdStringValidator.pattern(\"\\\\d*\".toRegex()))\n</code></pre> <ul> <li> <p>Define the validators <pre><code>//String validators\nval isNotBlank = StdStringValidator.isNotBlank&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx&gt;()\n//Object validators\nval additionalProperties = StdStructValidator.additionalProperties&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx&gt;()\n//Array validators\nval isNotEmptyArray = StdArrayValidator.isNotEmpty&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx&gt;()\n</code></pre></p> </li> <li> <p>Define the reader for the Phone type</p> </li> </ul> <pre><code>val PhoneReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, Phone&gt; = structReader {\nvalidation(additionalProperties)\nval title = property(required(name = \"title\", reader = NonEmptyStringReader))\nval number = property(required(name = \"number\", reader = PhoneNumberReader))\nreturns { _, _, location -&gt;\nPhone(title = +title, number = +number).toSuccess(location)\n}\n}\n</code></pre> <ul> <li>Define the reader for the Phones type</li> </ul> <pre><code>val PhonesReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, Phones&gt; = arrayReader {\nvalidation(isNotEmptyArray)\nreturns(items = PhoneReader)\n}.map { phones -&gt; Phones(phones) }\n</code></pre> <ul> <li>Define the reader for the User type</li> </ul> <pre><code>val UserReader: Reader&lt;ReaderErrorBuilders, ReaderOptions, ReaderCtx, User&gt; = structReader {\nval id = property(required(name = \"id\", reader = PositiveNumberReader))\nval name = property(required(name = \"name\", reader = NonEmptyStringReader))\nval phones = property(optional(name = \"phones\", reader = PhonesReader, default = { _, _ -&gt; Phones() }))\nreturns { _, _, location -&gt;\nUser(id = +id, name = +name, phones = +phones).toSuccess(location)\n}\n}\n</code></pre>"},{"location":"quickstart/#writing","title":"Writing","text":""},{"location":"quickstart/#serialization-the-user-object","title":"Serialization the User object","text":"<pre><code>val user = User(id = 42, name = \"user\", phones = Phones(listOf(Phone(title = \"mobil\", number = \"123456789\"))))\nval json = user.serialization(mapper = mapper, env = writerEnv, context = WriterCtx, writer = UserWriter)\n</code></pre>"},{"location":"quickstart/#define-the-environment-to-serialization-of-some-domain-type-using-the-writer","title":"Define the environment to serialization of some domain type using the writer","text":"<pre><code>val writerEnv =\nWriterEnv(options = WriterOptions(writerActionIfResultIsEmpty = WriterActionIfResultIsEmpty.RETURN_NOTHING))\n</code></pre> <ul> <li>Define the options for the writing environment</li> </ul> <pre><code>class WriterOptions(override val writerActionIfResultIsEmpty: WriterActionIfResultIsEmpty) :\nWriterActionBuilderIfResultIsEmptyOption\n</code></pre>"},{"location":"quickstart/#define-the-context-to-serialization-of-some-domain-type-using-the-writer","title":"Define the context to serialization of some domain type using the writer","text":"<pre><code>object WriterCtx\n</code></pre>"},{"location":"quickstart/#define-the-writers-for-some-domain-types","title":"Define the writers for some domain types","text":"<ul> <li>Define the generic writers</li> </ul> <pre><code>val StringWriter = stringWriter&lt;WriterOptions, WriterCtx&gt;()\nval IntWriter = intWriter&lt;WriterOptions, WriterCtx&gt;()\n</code></pre> <ul> <li>Define the writer for the Phone type</li> </ul> <pre><code>val PhoneWriter: Writer&lt;WriterOptions, WriterCtx, Phone&gt; = structWriter {\nproperty(nonNullable(name = \"title\", from = Phone::title, writer = StringWriter))\nproperty(nonNullable(name = \"number\", from = { -&gt; number }, writer = StringWriter))\n}\n</code></pre> <ul> <li>Define the writer for the Phones type</li> </ul> <pre><code>val PhonesWriter: Writer&lt;WriterOptions, WriterCtx, Iterable&lt;Phone&gt;&gt; = arrayWriter(PhoneWriter)\n</code></pre> <ul> <li>Define the writer for the User type</li> </ul> <pre><code>val UserWriter: Writer&lt;WriterOptions, WriterCtx, User&gt; = structWriter {\nproperty(nonNullable(name = \"id\", from = User::id, writer = IntWriter))\nproperty(nonNullable(name = \"name\", from = { -&gt; name }, writer = StringWriter))\nproperty(nonNullable(name = \"phones\", from = { -&gt; phones }, writer = PhonesWriter))\n}\n</code></pre>"},{"location":"readers/","title":"The Reader","text":"<p>Reader converters are used to convert from a ValueNode to another type.</p>"},{"location":"readers/#array-reared","title":"Array reared","text":""},{"location":"readers/#create-reader","title":"Create reader","text":""},{"location":"readers/#return-type-definition","title":"Return type definition","text":""},{"location":"readers/#addition-validation-to-reader","title":"Addition validation to reader","text":""},{"location":"readers/#struct-reared","title":"Struct reared","text":""},{"location":"readers/#create-reader_1","title":"Create reader","text":""},{"location":"readers/#defining-properties","title":"Defining properties","text":""},{"location":"readers/#return-type-definition_1","title":"Return type definition","text":""},{"location":"readers/#addition-validation-to-reader_1","title":"Addition validation to reader","text":""},{"location":"standard-tools/","title":"Standard tools","text":""},{"location":"standard-tools/#standard-readers","title":"Standard readers","text":"<ul> <li>Reader for the Byte type</li> <li>Reader for the Short type</li> <li>Reader for the Int type</li> <li>Reader for the Long type</li> <li>Reader for the Boolean type</li> <li>Reader for the String type</li> <li>Reader for the BigDecimal type</li> </ul>"},{"location":"standard-tools/#standard-writers","title":"Standard writers","text":"<ul> <li>Writer for the Byte type</li> <li>Writer for the Short type</li> <li>Writer for the Int type</li> <li>Writer for the Long type</li> <li>Writer for the Boolean type</li> <li>Writer for the String type</li> <li>Writer for the BigDecimal type</li> </ul>"},{"location":"standard-tools/#standard-validators","title":"Standard validators","text":""},{"location":"standard-tools/#the-string-validators","title":"The string validators","text":"<ul> <li>isNotEmpty</li> <li>isNotBlank</li> <li>pattern</li> <li>minLength</li> <li>maxLength</li> <li>isA</li> </ul>"},{"location":"standard-tools/#the-comparison-validators","title":"The comparison validators","text":"<ul> <li>min</li> <li>max</li> <li>eq</li> <li>ne</li> <li>gt</li> <li>ge</li> <li>lt</li> <li>le</li> </ul>"},{"location":"standard-tools/#the-array-validators","title":"The array validators","text":"<ul> <li>isNotEmpty</li> <li>minItems</li> <li>maxItems</li> </ul>"},{"location":"standard-tools/#the-struct-validators","title":"The struct validators","text":"<ul> <li>additionalProperties</li> <li>isNotEmpty</li> <li>minProperties</li> <li>maxProperties</li> </ul>"},{"location":"writers/","title":"The Writer","text":"<p>Writer converters are used to convert from some type to a ValueNode.</p>"},{"location":"writers/#array-writer","title":"Array writer","text":""},{"location":"writers/#create-writer","title":"Create writer","text":""},{"location":"writers/#struct-writer","title":"Struct writer","text":""},{"location":"writers/#create-writer_1","title":"Create writer","text":""}]}